#T has the role of N, we remove it
#We take the first U0 we find for the corresponding parameters
Rel_Diff=function(a_t , b_t , c_t){
TrainCurve=Main_Training_Base[Main_Training_Base$a==a_t &
Main_Training_Base$b==b_t &
Main_Training_Base$c==c_t,][
4:length(Main_Training_Base)]#Removes a,b,c
#We take the first U0 we find for the corresponding parameters to generate
#a new curve
TestCurve=Generate_Output(TrainCurve$U0[1],N,a_t,b_t,c_t)$Un[[1]]
CurveDiff(TrainCurve,TestCurve)
}
a_t=Main_Training_Base$a[1]
b_t=Main_Training_Base$b[1]
c_t=Main_Training_Base$c[1]
Rel_Diff(a_t , b_t , c_t)
# 4. Let All_U0 a vector containing a list of values of U0. Describe what the
# following function does :
a_t=0.5
b_t=3
c_t=0.6
All_U0=seq(from=1, to=10, by=1)
Predicted_Curves <- mapply(Generate_Output, All_U0 , N, a_t , b_t , c_t )
Predicted_Curves
f_Predicted_Curves=function(All_U0 , N, a_t , b_t , c_t){
mapply(Generate_Output, All_U0 , N, a_t , b_t , c_t )
}
f_obj = function(a_t , b_t , c_t, TrainingBase=Main_Training_Base){
#Takes the values of the time serie without a,b,c
TrainCurve=TrainingBase[TrainingBase$a==a_t &
TrainingBase$b==b_t &
TrainingBase$c==c_t,][4:length(TrainingBase)]
#We try all the curves for each U0 in the Training Base
TestCurves=f_Predicted_Curves(TrainCurve$U0 , N, a_t , b_t , c_t)
tmpDiff=c()
for (i in 1:ncol(TestCurves)){
tmpDiff=c(tmpDiff,CurveDiff(TrainCurve,TestCurves[,i]$Un[[1]]))
}
mean(tmpDiff)
}
a_t=Main_Training_Base$a[1]
b_t=Main_Training_Base$b[1]
c_t=Main_Training_Base$c[1]
f1_test=f_obj(a_t , b_t , c_t);f1_test
#This function seems to work, but we do not have at least two lines with the
#same combination a, b and c (and in addition a different U0).
#So let us add a temporary row that would suit us.
rowToClone=Main_Training_Base[1,]
#create a copy of the row with another U0
tempUn=Generate_Output(rowToClone$U0+1, N, rowToClone$a, rowToClone$b, rowToClone$c)
#Add some noise
tempUn$Un[[1]]=tempUn$Un[[1]]+t(rnorm(N+1,mean=0,sd=0.1))
Main_Training_Base[nrow(Main_Training_Base) + 1,] = c(tempUn$a,tempUn$b,tempUn$c,
tempUn$Un[[1]])
f2_test=f_obj(rowToClone$a , rowToClone$b , rowToClone$c);f2_test
#There are now 2 rows that are taken into account for f_obj, and it still works
f1_test;f2_test #As expected, the results are slightly different
#There are now 2 rows that are taken into account for f_obj, and it still works
c(f1_test,f2_test) #As expected, the results are slightly different
tmpDiff
a_t , b_t , c_t
c(a_t , b_t , c_t)
c(rowToClone$a, rowToClone$b, rowToClone$c))
c(rowToClone$a, rowToClone$b, rowToClone$c)
c(a_t , b_t , c_t)==c(rowToClone$a, rowToClone$b, rowToClone$c)
tmpDiff
mean(tmpDiff)
#Takes the values of the time serie without a,b,c
TrainCurve=TrainingBase[TrainingBase$a==a_t &
TrainingBase$b==b_t &
TrainingBase$c==c_t,][4:length(TrainingBase)]
#We try all the curves for each U0 in the Training Base
TestCurves=f_Predicted_Curves(TrainCurve$U0 , N, a_t , b_t , c_t)[,1]
tmpDiff=c()
for (i in 1:ncol(TestCurves)){
tmpDiff=c(tmpDiff,CurveDiff(TrainCurve,TestCurves[,i]$Un[[1]]))
}
ncol(TestCurves)
TestCurves
f_obj = function(a_t , b_t , c_t, TrainingBase=Main_Training_Base){
#Takes the values of the time serie without a,b,c
TrainCurve=TrainingBase[TrainingBase$a==a_t &
TrainingBase$b==b_t &
TrainingBase$c==c_t,][4:length(TrainingBase)]
#We try all the curves for each U0 in the Training Base
TestCurves=f_Predicted_Curves(TrainCurve$U0 , N, a_t , b_t , c_t)
tmpDiff=c()
for (i in 1:ncol(TestCurves)){
tmpDiff=c(tmpDiff,CurveDiff(TrainCurve,TestCurves[,i]$Un[[1]]))
}
mean(tmpDiff)
}
a_t=Main_Training_Base$a[1]
b_t=Main_Training_Base$b[1]
c_t=Main_Training_Base$c[1]
f1_test=f_obj(a_t , b_t , c_t);f1_test
a_t=Main_Training_Base$a[2]
b_t=Main_Training_Base$b[2]
c_t=Main_Training_Base$c[2]
f2_test=f_obj(a_t , b_t , c_t);f2_test
a_t=Main_Training_Base$a[2]
b_t=Main_Training_Base$b[2]
c_t=Main_Training_Base$c[2]
f2_test=f_obj(a_t , b_t , c_t);f2_test
a_t=Main_Training_Base$a[1]
b_t=Main_Training_Base$b[1]
c_t=Main_Training_Base$c[1]
f1_test=f_obj(a_t , b_t , c_t);f1_test
#This function seems to work, but we do not have at least two lines with the
#same combination a, b and c (and in addition a different U0).
#So let us add a temporary row that would suit us.
rowToClone=Main_Training_Base[1,]
#create a copy of the row with another U0
tempUn=Generate_Output(rowToClone$U0+1, N, rowToClone$a, rowToClone$b, rowToClone$c)
#We confirm that we use the same parameters as in the above test
c(a_t , b_t , c_t)==c(rowToClone$a, rowToClone$b, rowToClone$c)
Main_Training_Base = Main_Learning_Base[baseSplit, ]
dim(Main_Training_Base)
Main_Test_Base = Main_Learning_Base[!baseSplit, ]
dim(Main_Test_Base)
#Let us take the sum of the norm 2 distance between each point at a same index
#for the difference between two vectors representing the Y-values of the curves
#each having the same length
CurveDiff=function(Curve1,Curve2){
if (length(Curve1)!=length(Curve2)){
return (NaN)
}
sumDiff=sqrt(sum((2*(Curve1-Curve2)/(Curve1+Curve2))**2))/length(Curve1)
sumDiff
}
Curve1=Main_Training_Base[1,4:44]
Curve2=Main_Training_Base[2,4:44]
CurveDiff(Curve1,Curve2)
Curve1=Main_Training_Base[2,4:44]
Curve2=Main_Training_Base[1,4:44]
CurveDiff(Curve1,Curve2)
Curve1=Main_Training_Base[1,4:44]
Curve2=Main_Training_Base[5,4:44]
CurveDiff(Curve1,Curve2)
Curve1=Main_Training_Base[5,4:44]
Curve2=Main_Training_Base[2,4:44]
CurveDiff(Curve1,Curve2)
#T has the role of N, we remove it
#We take the first U0 we find for the corresponding parameters
Rel_Diff=function(a_t , b_t , c_t){
TrainCurve=Main_Training_Base[Main_Training_Base$a==a_t &
Main_Training_Base$b==b_t &
Main_Training_Base$c==c_t,][
4:length(Main_Training_Base)]#Removes a,b,c
#We take the first U0 we find for the corresponding parameters to generate
#a new curve
TestCurve=Generate_Output(TrainCurve$U0[1],N,a_t,b_t,c_t)$Un[[1]]
CurveDiff(TrainCurve,TestCurve)
}
a_t=Main_Training_Base$a[1]
b_t=Main_Training_Base$b[1]
c_t=Main_Training_Base$c[1]
Rel_Diff(a_t , b_t , c_t)
# 4. Let All_U0 a vector containing a list of values of U0. Describe what the
# following function does :
a_t=0.5
b_t=3
c_t=0.6
All_U0=seq(from=1, to=10, by=1)
Predicted_Curves <- mapply(Generate_Output, All_U0 , N, a_t , b_t , c_t )
Predicted_Curves
f_Predicted_Curves=function(All_U0 , N, a_t , b_t , c_t){
mapply(Generate_Output, All_U0 , N, a_t , b_t , c_t )
}
f_obj = function(a_t , b_t , c_t, TrainingBase=Main_Training_Base){
#Takes the values of the time serie without a,b,c
TrainCurve=TrainingBase[TrainingBase$a==a_t &
TrainingBase$b==b_t &
TrainingBase$c==c_t,][4:length(TrainingBase)]
#We try all the curves for each U0 in the Training Base
TestCurves=f_Predicted_Curves(TrainCurve$U0 , N, a_t , b_t , c_t)
tmpDiff=c()
for (i in 1:ncol(TestCurves)){
tmpDiff=c(tmpDiff,CurveDiff(TrainCurve,TestCurves[,i]$Un[[1]]))
}
mean(tmpDiff)
}
a_t=Main_Training_Base$a[2]
b_t=Main_Training_Base$b[2]
c_t=Main_Training_Base$c[2]
f2_test=f_obj(a_t , b_t , c_t);f2_test
a_t=Main_Training_Base$a[1]
b_t=Main_Training_Base$b[1]
c_t=Main_Training_Base$c[1]
f1_test=f_obj(a_t , b_t , c_t);f1_test
#This function seems to work, but we do not have at least two lines with the
#same combination a, b and c (and in addition a different U0).
#So let us add a temporary row that would suit us.
Copy_Training_Base=Main_Training_Base
rowToClone=Copy_Training_Base[1,]
#create a copy of the row with another U0
tempUn=Generate_Output(rowToClone$U0+1, N, rowToClone$a, rowToClone$b, rowToClone$c)
#We confirm that we use the same parameters as in the above test
c(a_t , b_t , c_t)==c(rowToClone$a, rowToClone$b, rowToClone$c)
#Add some noise
tempUn$Un[[1]]=tempUn$Un[[1]]+t(rnorm(N+1,mean=0,sd=0.1))
Copy_Training_Base[nrow(Copy_Training_Base) + 1,] = c(tempUn$a,tempUn$b,tempUn$c,
tempUn$Un[[1]])
f1b_test=f_obj(rowToClone$a , rowToClone$b , rowToClone$c);f2_test
#There are now 2 rows that are taken into account for f_obj, and it still works
c(f1_test,f1b_test) #As expected, the results are different
#This function seems to work, but we do not have at least two lines with the
#same combination a, b and c (and in addition a different U0).
#So let us add a temporary row that would suit us.
Copy_Training_Base=Main_Training_Base
rowToClone=Copy_Training_Base[1,]
#create a copy of the row with another U0
tempUn=Generate_Output(rowToClone$U0+1, N, rowToClone$a, rowToClone$b, rowToClone$c)
#We confirm that we use the same parameters as in the above test
c(a_t , b_t , c_t)==c(rowToClone$a, rowToClone$b, rowToClone$c)
#Add some noise
tempUn$Un[[1]]=tempUn$Un[[1]]+t(rnorm(N+1,mean=0,sd=0.1))
Copy_Training_Base[nrow(Copy_Training_Base) + 1,] = c(tempUn$a,tempUn$b,tempUn$c,
tempUn$Un[[1]])
f1b_test=f_obj(rowToClone$a , rowToClone$b , rowToClone$c, Copy_Training_Base)
f2_test
#There are now 2 rows that are taken into account for f_obj, and it still works
c(f1_test,f1b_test) #As expected, the results are different
f1b_test=f_obj(rowToClone$a , rowToClone$b , rowToClone$c, Copy_Training_Base)
fb_test
#This function seems to work, but we do not have at least two lines with the
#same combination a, b and c (and in addition a different U0).
#So let us add a temporary row that would suit us.
Copy_Training_Base=Main_Training_Base
rowToClone=Copy_Training_Base[1,]
#create a copy of the row with another U0
tempUn=Generate_Output(rowToClone$U0+1, N, rowToClone$a, rowToClone$b, rowToClone$c)
#We confirm that we use the same parameters as in the above test
c(a_t , b_t , c_t)==c(rowToClone$a, rowToClone$b, rowToClone$c)
#Add some noise
tempUn$Un[[1]]=tempUn$Un[[1]]+t(rnorm(N+1,mean=0,sd=0.1))
Copy_Training_Base[nrow(Copy_Training_Base) + 1,] = c(tempUn$a,tempUn$b,tempUn$c,
tempUn$Un[[1]])
f1b_test=f_obj(rowToClone$a , rowToClone$b , rowToClone$c, Copy_Training_Base)
f1b_test
#There are now 2 rows that are taken into account for f_obj, and it still works
c(f1_test,f1b_test) #As expected, the results are different
a_t=Main_Training_Base$a[2]
b_t=Main_Training_Base$b[2]
c_t=Main_Training_Base$c[2]
f2_test=f_obj(a_t , b_t , c_t);f2_test
a_t=Main_Training_Base$a[1]
b_t=Main_Training_Base$b[1]
c_t=Main_Training_Base$c[1]
f1_test=f_obj(a_t , b_t , c_t);f1_test
#This function seems to work, but we do not have at least two lines with the
#same combination a, b and c (and in addition a different U0).
#So let us add a temporary row that would suit us.
Copy_Training_Base=Main_Training_Base
rowToClone=Copy_Training_Base[1,]
#create a copy of the row with another U0
tempUn=Generate_Output(rowToClone$U0+1, N, rowToClone$a, rowToClone$b, rowToClone$c)
#We confirm that we use the same parameters as in the above test
c(a_t , b_t , c_t)==c(rowToClone$a, rowToClone$b, rowToClone$c)
#Add some noise
tempUn$Un[[1]]=tempUn$Un[[1]]+t(rnorm(N+1,mean=0,sd=0.1))
Copy_Training_Base[nrow(Copy_Training_Base) + 1,] = c(tempUn$a,tempUn$b,tempUn$c,
tempUn$Un[[1]])
f1b_test=f_obj(rowToClone$a , rowToClone$b , rowToClone$c, Copy_Training_Base)
f1b_test
#There are now 2 rows that are taken into account for f_obj, and it still works
c(f1_test,f1b_test) #As expected, the results are different
rd2_test=Rel_Diff(a_t , b_t , c_t);rd2_test
f2_test=f_obj(a_t , b_t , c_t);f2_test
rd2_test=Rel_Diff(a_t , b_t , c_t);rd2_test
rd2_test==f2_test
a_t=Main_Training_Base$a[1]
b_t=Main_Training_Base$b[1]
c_t=Main_Training_Base$c[1]
f1_test=f_obj(a_t , b_t , c_t);f1_test
rd1_test=Rel_Diff(a_t , b_t , c_t);rd1_test
rd1_test==f1_test
#T has the role of N, we remove it
#We take the first U0 we find for the corresponding parameters
Rel_Diff=function(a_t , b_t , c_t, TrainingBase=Main_Training_Base){
TrainCurve=TrainingBase[TrainingBase$a==a_t &
TrainingBase$b==b_t &
TrainingBase$c==c_t,][
4:length(TrainingBase)]#Removes a,b,c
#We take the first U0 we find for the corresponding parameters to generate
#a new curve
TestCurve=Generate_Output(TrainCurve$U0[1],N,a_t,b_t,c_t)$Un[[1]]
CurveDiff(TrainCurve,TestCurve)
}
a_t=Main_Training_Base$a[1]
b_t=Main_Training_Base$b[1]
c_t=Main_Training_Base$c[1]
Rel_Diff(a_t , b_t , c_t)
# 4. Let All_U0 a vector containing a list of values of U0. Describe what the
# following function does :
a_t=0.5
b_t=3
c_t=0.6
All_U0=seq(from=1, to=10, by=1)
Predicted_Curves <- mapply(Generate_Output, All_U0 , N, a_t , b_t , c_t )
Predicted_Curves
f_Predicted_Curves=function(All_U0 , N, a_t , b_t , c_t){
mapply(Generate_Output, All_U0 , N, a_t , b_t , c_t )
}
f_obj = function(a_t , b_t , c_t, TrainingBase=Main_Training_Base){
#Takes the values of the time serie without a,b,c
TrainCurve=TrainingBase[TrainingBase$a==a_t &
TrainingBase$b==b_t &
TrainingBase$c==c_t,][4:length(TrainingBase)]
#We try all the curves for each U0 in the Training Base
TestCurves=f_Predicted_Curves(TrainCurve$U0 , N, a_t , b_t , c_t)
tmpDiff=c()
for (i in 1:ncol(TestCurves)){
tmpDiff=c(tmpDiff,CurveDiff(TrainCurve,TestCurves[,i]$Un[[1]]))
}
mean(tmpDiff)
}
a_t=Main_Training_Base$a[2]
b_t=Main_Training_Base$b[2]
c_t=Main_Training_Base$c[2]
f2_test=f_obj(a_t , b_t , c_t);f2_test
rd2_test=Rel_Diff(a_t , b_t , c_t);rd2_test
rd2_test==f2_test
a_t=Main_Training_Base$a[1]
b_t=Main_Training_Base$b[1]
c_t=Main_Training_Base$c[1]
f1_test=f_obj(a_t , b_t , c_t);f1_test
rd1_test=Rel_Diff(a_t , b_t , c_t);rd1_test
rd1_test==f1_test
#Takes the values of the time serie without a,b,c
TrainCurve=TrainingBase[TrainingBase$a==a_t &
TrainingBase$b==b_t &
TrainingBase$c==c_t,][4:length(TrainingBase)]
#We try all the curves for each U0 in the Training Base
TestCurves=f_Predicted_Curves(TrainCurve$U0 , N, a_t , b_t , c_t)
a_t
Main_Training_Base$a[1]
TestCurves
tmpDiff=c(tmpDiff,CurveDiff(TrainCurve,TestCurves[,i]$Un[[1]]))
tmpDiff
tmpDiff=c()
for (i in 1:ncol(TestCurves)){
tmpDiff=c(tmpDiff,CurveDiff(TrainCurve,TestCurves[,i]$Un[[1]]))
}
tmpDiff
Rel_Diff(a_t , b_t , c_t)
Rel_Diff(a_t , b_t , c_t,TrainingBase = Copy_Training_Base)
#f_obj and Rel_Diff return the same results for identical parameters.
#This function seems to work, but we do not have at least two lines with the
#same combination a, b and c (and in addition a different U0) in the database.
#So let us add a temporary row that would suit us.
Copy_Training_Base=Main_Training_Base
#f_obj and Rel_Diff return the same results for identical parameters.
#This function seems to work, but we do not have at least two lines with the
#same combination a, b and c (and in addition a different U0) in the database.
#So let us add a temporary row that would suit us.
Copy_Training_Base=Main_Training_Base
View(Copy_Training_Base)
View(Main_Training_Base)
rowToClone=Copy_Training_Base[1,]
#create a copy of the row with another U0
tempUn=Generate_Output(rowToClone$U0+1, N, rowToClone$a, rowToClone$b, rowToClone$c)
#We confirm that we use the same parameters as in the above test
c(a_t , b_t , c_t)==c(rowToClone$a, rowToClone$b, rowToClone$c)
#Add some noise
tempUn$Un[[1]]=tempUn$Un[[1]]+t(rnorm(N+1,mean=0,sd=0.1))
Copy_Training_Base[nrow(Copy_Training_Base) + 1,] = c(tempUn$a,tempUn$b,tempUn$c,
tempUn$Un[[1]])
Main_Training_Base[13,]
#f_obj and Rel_Diff return the same results for identical parameters.
#This function seems to work, but we do not have at least two lines with the
#same combination a, b and c (and in addition a different U0) in the database.
#So let us add a temporary row that would suit us.
Copy_Training_Base=Main_Training_Base
rowToClone=Copy_Training_Base[1,]
#create a copy of the row with another U0
tempUn=Generate_Output(rowToClone$U0+1, N, rowToClone$a, rowToClone$b, rowToClone$c)
#We confirm that we use the same parameters as in the above test
c(a_t , b_t , c_t)==c(rowToClone$a, rowToClone$b, rowToClone$c)
#Add some noise
tempUn$Un[[1]]=tempUn$Un[[1]]+t(rnorm(N+1,mean=0,sd=0.1))
rowToAdd=c(tempUn$a,tempUn$b,tempUn$c,  tempUn$Un[[1]])
rowToAdd=c(tempUn$a,tempUn$b,tempUn$c,  tempUn$Un[[1]])
Copy_Training_Base[nrow(Copy_Training_Base) + 1,] = rowToAdd
TrainingBase=Main_Training_Base
#Takes the values of the time serie without a,b,c
TrainCurve=TrainingBase[TrainingBase$a==a_t &
TrainingBase$b==b_t &
TrainingBase$c==c_t,][4:length(TrainingBase)]
TrainCurve
tmp1TC=TrainCurve
TrainingBase=Copy_Training_Base
#Takes the values of the time serie without a,b,c
TrainCurve=TrainingBase[TrainingBase$a==a_t &
TrainingBase$b==b_t &
TrainingBase$c==c_t,][4:length(TrainingBase)]
TrainCurve
TrainCurve[1,]
tmp2=TrainCurve[1,]
tmp1==tmp2
tmp2TC=TrainCurve[1,]
tmp1TC==tmp2TC
TrainCurve=tmp1TC
#We try all the curves for each U0 in the Training Base
TestCurves=f_Predicted_Curves(TrainCurve$U0 , N, a_t , b_t , c_t)
TestCurve1=TestCurves
TestCurves
TrainCurve=tmp2TC
#We try all the curves for each U0 in the Training Base
TestCurves=f_Predicted_Curves(TrainCurve$U0 , N, a_t , b_t , c_t)
TestCurves2=TestCurves
TestCurve1==TestCurves2
TestCurve1[,1]==TestCurves2[,1]
TestCurve1[,1]$Un==TestCurves2[,1]$Un
TestCurve1[,1]$Un[[1]]==TestCurves2[,1]$Un[[1]]
Main_Training_Base
TrainingBase=Main_Training_Base
#Takes the values of the time serie without a,b,c
TrainCurve=TrainingBase[TrainingBase$a==a_t &
TrainingBase$b==b_t &
TrainingBase$c==c_t,][4:length(TrainingBase)]
TrainCurve1=TrainCurve
#We try all the curves for each U0 in the Training Base
TestCurves=f_Predicted_Curves(TrainCurve$U0 , N, a_t , b_t , c_t)
TC1=TestCurves
TestCurves
TrainingBase=Copy_Training_Base
#Takes the values of the time serie without a,b,c
TrainCurve=TrainingBase[TrainingBase$a==a_t &
TrainingBase$b==b_t &
TrainingBase$c==c_t,][4:length(TrainingBase)]
#We try all the curves for each U0 in the Training Base
TestCurves=f_Predicted_Curves(TrainCurve$U0 , N, a_t , b_t , c_t)
TC2=TestCurves
TestCurves
TC1[,1]$Un[[1]]==TC1[,2]$Un[[1]]
TC1[,1]$Un[[1]]==TC2[,1]$Un[[1]]
TestCurves=TC1
tmpDiff=c()
for (i in 1:ncol(TestCurves)){
tmpDiff=c(tmpDiff,CurveDiff(TrainCurve,TestCurves[,i]$Un[[1]]))
}
tmpDiff
TestCurves=TC2
tmpDiff=c()
for (i in 1:ncol(TestCurves)){
tmpDiff=c(tmpDiff,CurveDiff(TrainCurve,TestCurves[,i]$Un[[1]]))
}
tmpDiff
mean(tmpDiff)
TrainingBase=Main_Training_Base
#Takes the values of the time serie without a,b,c
TrainCurve=TrainingBase[TrainingBase$a==a_t &
TrainingBase$b==b_t &
TrainingBase$c==c_t,][4:length(TrainingBase)]
#We try all the curves for each U0 in the Training Base
TestCurves=f_Predicted_Curves(TrainCurve$U0 , N, a_t , b_t , c_t)
tmpDiff=c()
for (i in 1:ncol(TestCurves)){
tmpDiff=c(tmpDiff,CurveDiff(TrainCurve,TestCurves[,i]$Un[[1]]))
}
tmpDiff
TrainCurve
TrainingBase=Copy_Training_Base
#Takes the values of the time serie without a,b,c
TrainCurve=TrainingBase[TrainingBase$a==a_t &
TrainingBase$b==b_t &
TrainingBase$c==c_t,][4:length(TrainingBase)]
TrainCurve
f_obj = function(a_t , b_t , c_t, TrainingBase=Main_Training_Base){
#Takes the values of the time serie without a,b,c
TrainCurve=TrainingBase[TrainingBase$a==a_t &
TrainingBase$b==b_t &
TrainingBase$c==c_t,][4:length(TrainingBase)]
#We try all the curves for each U0 in the Training Base
TestCurves=f_Predicted_Curves(TrainCurve$U0 , N, a_t , b_t , c_t)
tmpDiff=c()
for (i in 1:ncol(TestCurves)){
tmpDiff=c(tmpDiff,CurveDiff(TrainCurve[i,],TestCurves[,i]$Un[[1]]))
}
mean(tmpDiff)
}
a_t=Main_Training_Base$a[2]
b_t=Main_Training_Base$b[2]
c_t=Main_Training_Base$c[2]
f2_test=f_obj(a_t , b_t , c_t);f2_test
rd2_test=Rel_Diff(a_t , b_t , c_t);rd2_test
rd2_test==f2_test
a_t=Main_Training_Base$a[1]
b_t=Main_Training_Base$b[1]
c_t=Main_Training_Base$c[1]
f1_test=f_obj(a_t , b_t , c_t);f1_test
rd1_test=Rel_Diff(a_t , b_t , c_t);rd1_test
rd1_test==f1_test
#f_obj and Rel_Diff return the same results for identical parameters.
#This function seems to work, but we do not have at least two lines with the
#same combination a, b and c (and in addition a different U0) in the database.
#So let us add a temporary row that would suit us.
Copy_Training_Base=Main_Training_Base
rowToClone=Copy_Training_Base[1,]
#create a copy of the row with another U0
tempUn=Generate_Output(rowToClone$U0+1, N, rowToClone$a, rowToClone$b, rowToClone$c)
#We confirm that we use the same parameters as in the above test
c(a_t , b_t , c_t)==c(rowToClone$a, rowToClone$b, rowToClone$c)
#Add some noise
tempUn$Un[[1]]=tempUn$Un[[1]]+t(rnorm(N+1,mean=0,sd=0.1))
rowToAdd=c(tempUn$a,tempUn$b,tempUn$c,  tempUn$Un[[1]])
Copy_Training_Base[nrow(Copy_Training_Base) + 1,] = rowToAdd
f1b_test=f_obj(rowToClone$a , rowToClone$b , rowToClone$c, Copy_Training_Base)
f1b_test
#There are now 2 rows that are taken into account for f_obj, and it still works
c(f1_test,f1b_test) #As expected, the results are different
